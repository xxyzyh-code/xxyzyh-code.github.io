<div id="custom-audio-player">
    <h3>我的音樂播放器</h3>
    
    <audio id="main-audio" controls src="{{ site.data.music[0].url }}">
        您的瀏覽器不支持 HTML5 音頻。
    </audio>
    
<div id="player-controls">
    <span id="mode-button" onclick="togglePlayMode()">
        [ 模式: 順序 ]
    </span>
    
    <div id="theme-switcher">
    <button id="theme-toggle-btn">
        主題 (當前: <span id="current-theme-name">白色 (自動)</span>)
    </button>
    <div id="theme-menu" class="hidden-menu">
        <span class="theme-option" data-theme="light">白色</span>
        <span class="theme-option" data-theme="dark">黑色</span>
        <span class="theme-option" data-theme="grey">灰色</span>
    </div>
</div>

    <div id="sleep-timer-area">
        <button id="timer-toggle-btn" onclick="toggleTimerMenu()">
            定時 (未設定)
        </button>
        
        <div id="timer-menu" class="hidden-menu">
            <span class="menu-item" onclick="setSleepTimer(10)">10 分鐘後關閉</span>
            <span class="menu-item" onclick="setSleepTimer(30)">30 分鐘後關閉</span>
            <span class="menu-item" onclick="setSleepTimer(60)">60 分鐘後關閉</span>
            <span class="menu-item" onclick="clearSleepTimer(); toggleTimerMenu();">取消定時</span>
        </div>
    </div>
</div>
    
    
    <div id="stats-bar">
        <span>總時長: <span id="total-listen-time">0 分鐘</span></span>
        <span>剩餘: <span id="remaining-timer">--:--</span></span>
    </div>
    
    <ul id="playlist">
    {% for track in site.data.music %}
        <li data-url="{{ track.url }}" onclick="loadTrack('{{ track.url }}', '{{ track.title }}', {{ forloop.index0 }})">
            {{ track.title }} - {{ track.artist }}
        </li>
    {% endfor %}
    </ul>
</div>


<script>
// 獲取 DOM 元素
const audio = document.getElementById('main-audio');
const playerTitle = document.querySelector('#custom-audio-player h3');
const playlistItems = document.querySelectorAll('#playlist li'); 
const modeButton = document.getElementById('mode-button'); 

// 新增 DOM 元素
const timerToggleButton = document.getElementById('timer-toggle-btn');
const timerMenu = document.getElementById('timer-menu');
const totalListenTimeSpan = document.getElementById('total-listen-time');
const remainingTimerSpan = document.getElementById('remaining-timer');

// *** 主題切換相關 DOM 元素 (頂層定義) ***
const themeToggleBtn = document.getElementById('theme-toggle-btn');
const themeMenu = document.getElementById('theme-menu');
const currentThemeName = document.getElementById('current-theme-name');
const themeOptions = document.querySelectorAll('#theme-menu .theme-option');
    
    
// 1. 準備數據和狀態追蹤
const trackList = [
{% for track in site.data.music %}
    { title: "{{ track.title | escape }}", url: "{{ track.url | escape }}" },
{% endfor %}
];

let currentTrackIndex = 0; 
// 播放模式：0=順序, 1=循環, 2=隨機, 3=自由(播完即停)
let playMode = 0; 

// 定時器狀態變數
let sleepTimerId = null; 
let sleepTime = 0; 
let endTime = 0; 
let countdownIntervalId = null; 

// 總時長追蹤變數
let totalListenMinutes = 0;
let totalListenSeconds = 0;
let listenIntervalId = null; 


// --- 輔助函數 ---

// 載入並播放指定索引的歌曲
function playTrack(index) {
    if (index >= 0 && index < trackList.length) {
        currentTrackIndex = index;
        const track = trackList[index];
        audio.src = track.url;
        playerTitle.textContent = `正在播放：${track.title}`;
        audio.play().catch(error => {
            console.error("自動播放失敗，可能是瀏覽器限制：", error);
        });
        updatePlaylistHighlight();
    } else if (index === trackList.length) {
        audio.pause(); 
        playerTitle.textContent = "播放列表已結束";
        currentTrackIndex = -1; 
        updatePlaylistHighlight();
    }
}

// 獲取隨機索引
function getNextRandomIndex() {
    let newIndex;
    do {
        newIndex = Math.floor(Math.random() * trackList.length);
    } while (newIndex === currentTrackIndex && trackList.length > 1);
    
    return newIndex;
}

// 更新播放列表的高亮狀態
function updatePlaylistHighlight() {
    playlistItems.forEach((item, index) => {
        item.classList.remove('playing');
        if (index === currentTrackIndex) {
            item.classList.add('playing');
        }
    });
}


// --- 核心邏輯：控制播放順序/循環/隨機/自由 ---

audio.addEventListener('ended', () => {
    if (playMode === 1) {
        audio.currentTime = 0; 
        audio.play();
    } else if (playMode === 2) {
        const nextIndex = getNextRandomIndex();
        playTrack(nextIndex);
    } else if (playMode === 3) {
        audio.pause();
        playerTitle.textContent = "自由模式下，當前歌曲播放完畢。";
        currentTrackIndex = -1; 
        updatePlaylistHighlight();
    } 
    else {
        if (currentTrackIndex < trackList.length - 1) {
            playTrack(currentTrackIndex + 1); 
        } else {
            playTrack(trackList.length); 
        }
    }
});


// 模式切換函數
function togglePlayMode() {
    playMode = (playMode + 1) % 4; 
    
    let modeText;
    let titleMessage;
    
    if (playMode === 1) {
        modeText = "[ 模式: 循環 ]";
        titleMessage = "已切換到單曲循環模式";
    } else if (playMode === 2) {
        modeText = "[ 模式: 隨機 ]";
        titleMessage = "已切換到隨機播放模式";
    } else if (playMode === 3) {
        modeText = "[ 模式: 自由 ]";
        titleMessage = "已切換到自由播放模式 (播完即停)";
    } else {
        modeText = "[ 模式: 順序 ]";
        titleMessage = "已切換到順序播放模式";
    }
    
    modeButton.textContent = modeText;
    playerTitle.textContent = titleMessage;

    // 儲存播放模式到 localStorage
    saveSettings(); 
}


// --- *** 主題切換邏輯 (重構為完全手動切換優先) *** ---

const THEME_STORAGE_KEY = 'userThemePreference';
const LIGHT_THEME = 'light'; // 內部標籤：白色
const DARK_THEME = 'dark';   // 內部標籤：黑色
const GREY_THEME = 'grey';   // 內部標籤：灰色

/**
 * 設置主題類名並更新按鈕顯示
 * 這是主題的核心函數，所有主題切換都通過它
 * @param {string} desiredTheme - 'light', 'dark', 'grey' (使用者手動選擇的意圖)
 * @param {boolean} isManual - 是否為手動選擇 (點擊菜單選項時為 true)
 */
function applyTheme(desiredTheme, isManual = false) {
    const body = document.body;
    let displayName = '';
    
    // 1. 清除所有主題類名 (無論是哪個主題，都先清除乾淨)
    body.classList.remove(DARK_THEME + '-theme', GREY_THEME + '-theme');

    let themeToApply = desiredTheme;
    let modeText = '(手動)'; // 預設為手動，除非進入自動判斷流程

    // 2. 處理儲存：如果是手動選擇，儲存使用者的意圖
    if (isManual) {
        localStorage.setItem(THEME_STORAGE_KEY, desiredTheme);
    } 
    // 處理頁面載入時的「自動模式」：
    else if (desiredTheme === LIGHT_THEME) {
        // 如果是初始載入且儲存的意圖是 'light'，則進入自動模式判斷
        themeToApply = getSystemThemeBasedOnTime();
        modeText = '(自動)';
        // 如果自動判斷結果是淺色，則 themeToApply 仍然是 'light'，無需加 class
    }


    // 3. 根據最終確定的主題 themeToApply 應用類名
    if (themeToApply === DARK_THEME) {
        body.classList.add(DARK_THEME + '-theme');
        displayName = '黑色';
    } else if (themeToApply === GREY_THEME) {
        body.classList.add(GREY_THEME + '-theme');
        displayName = '灰色';
    } else { 
        // themeToApply 是 'light'：強制使用白色 (預設，不加類名)
        displayName = '白色';
    }
    
    // 4. 更新按鈕顯示
    currentThemeName.textContent = `${displayName} ${modeText}`;
}


/**
 * 根據當地時間判斷應該使用淺色還是深色
 * (夜間定義：19:00 (含) 到 07:00 (不含))
 * @returns {string} 'dark' 或 'light'
 */
function getSystemThemeBasedOnTime() {
    const hour = new Date().getHours();
    // 晚上 19 點到早上 7 點之間使用深色 (黑色)
    return (hour >= 19 || hour < 7) ? DARK_THEME : LIGHT_THEME;
}

/**
 * 初始化主題：從 localStorage 讀取或根據時間自動判斷
 */
function initializeTheme() {
    const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
    
    // 如果儲存了任意主題 (light, dark, grey)，則應用該主題作為手動選擇
    if (storedTheme) {
        // 如果儲存的是 light，我們將其視為用戶期望回到自動模式
        if (storedTheme === LIGHT_THEME) {
             applyTheme(LIGHT_THEME, false); // false = 讓它進入自動判斷
        } else {
             applyTheme(storedTheme, true); // true = 應用手動選擇 (深色或灰色)
        }
    } else {
        // 沒有儲存，預設使用自動模式
        applyTheme(LIGHT_THEME, false);
    }
}

// --- 主題事件監聽器 (新增和修正) ---

/**
 * 點擊主題切換按鈕，切換選單顯示
 */
themeToggleBtn.addEventListener('click', (event) => {
    // 阻止事件冒泡，防止被 document 點擊事件立刻關閉
    event.stopPropagation(); 
    // 核心邏輯：切換隱藏狀態
    themeMenu.classList.toggle('hidden-menu');
});


// 點擊選單選項，應用新的主題
themeOptions.forEach(option => {
    option.addEventListener('click', (e) => {
        const selectedTheme = e.target.getAttribute('data-theme');
        // *** 關鍵修正：將 isManual 設為 true，強制應用該主題 ***
        applyTheme(selectedTheme, true); 
        // 選擇後自動收起菜單
        themeMenu.classList.add('hidden-menu'); 
    });
});


// ** BONUS: 點擊頁面其他地方時，隱藏選單 **
document.addEventListener('click', (e) => {
    // 檢查點擊是否在按鈕或選單內部
    if (!themeMenu.contains(e.target) && !themeToggleBtn.contains(e.target)) {
        themeMenu.classList.add('hidden-menu');
    }
});



// ** BONUS: 定期檢查時間以應對跨越日夜的時間 (僅用於自動模式) **
setInterval(() => {
    const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
    
    // 只有當前儲存的主題是 'light' (意圖為自動模式) 時，才需要根據時間自動更新
    if (storedTheme === LIGHT_THEME) {
        // 重新執行自動判斷邏輯
        applyTheme(LIGHT_THEME, false); 
    }
}, 1000 * 60 * 60); // 每小時檢查一次

    
    
// --- 定時器/統計邏輯 (保持不變) ---

function toggleTimerMenu() {
    timerMenu.classList.toggle('hidden-menu');
}

function setSleepTimer(minutes) {
    clearSleepTimer();
    toggleTimerMenu(); 

    const delayMilliseconds = minutes * 60 * 1000;
    
    sleepTime = minutes * 60;
    endTime = Date.now() + delayMilliseconds;

    sleepTimerId = setTimeout(() => {
        audio.pause(); 
        playerTitle.textContent = `定時器到期，已暫停播放 (${minutes} 分鐘)`;
        clearSleepTimer(); 
    }, delayMilliseconds);
    
    countdownIntervalId = setInterval(updateTimerCountdown, 1000);

    timerToggleButton.textContent = `定時 (${minutes} 分鐘)`;
    playerTitle.textContent = `定時器已設置：${minutes} 分鐘後自動關閉`;

    if (audio.paused) {
        audio.play();
    }
}

function clearSleepTimer() {
    if (sleepTimerId !== null) {
        clearTimeout(sleepTimerId);
        sleepTimerId = null;
    }
    if (countdownIntervalId !== null) {
        clearInterval(countdownIntervalId);
        countdownIntervalId = null;
    }
    
    sleepTime = 0;
    endTime = 0;
    timerToggleButton.textContent = "定時 (未設定)";
    remainingTimerSpan.textContent = "--:--";
    playerTitle.textContent = "已取消定時器";
}

/**
 * 更新倒數計時顯示，基於目標結束時間 (endTime) 計算
 */
function updateTimerCountdown() {
    if (endTime > 0) {
        // 關鍵修正：計算當前時間與目標時間的精確差值
        const remainingMs = endTime - Date.now();
        
        // 確保剩餘時間不為負數
        const remainingS = Math.max(0, Math.floor(remainingMs / 1000));
        
        const minutes = Math.floor(remainingS / 60);
        const seconds = remainingS % 60;
        
        remainingTimerSpan.textContent = 
            `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
        // 如果時間到期，清除計時器
        if (remainingS === 0) {
            clearSleepTimer(); 
            
            // 如果倒數計時已經結束，我們也應該停止音頻
            // 雖然定時器到期邏輯在 setTimeout 裡，這裡增加一個保險
            if (!audio.paused) {
                 audio.pause();
                 playerTitle.textContent = `定時器到期，已暫停播放`;
            }
        }
    }
}


audio.addEventListener('play', () => {
    if (listenIntervalId === null) {
        listenIntervalId = setInterval(updateTotalListenTime, 1000);
    }
});

audio.addEventListener('pause', () => {
    if (listenIntervalId !== null) {
        clearInterval(listenIntervalId);
        listenIntervalId = null;
    }
});

function updateTotalListenTime() {
    totalListenSeconds++;
    if (totalListenSeconds >= 60) {
        totalListenMinutes++;
        totalListenSeconds = 0;
    }
    
    totalListenTimeSpan.textContent = 
        `${totalListenMinutes} 分鐘 ${totalListenSeconds} 秒`;
}


// --- 外部呼叫函數 (來自列表點擊) ---

function loadTrack(url, title, index) {
    // 點擊列表後，自動切換到「自由模式」 (Mode 3)
    if (playMode !== 3) {
        playMode = 3;
        modeButton.textContent = "[ 模式: 自由 ]";
        playerTitle.textContent = "已切換到自由播放模式 (點擊列表)";
        // *** 新增：儲存播放模式到 localStorage ***
        saveSettings(); 
    }
    playTrack(index);
}


// --- *** LocalStorage 邏輯 (修正音量儲存) *** ---

// 儲存當前音量、靜音狀態和模式
function saveSettings() {
    try {
        // 保存音量值
        localStorage.setItem('audioPlayerVolume', audio.volume);
        // *** 修正：同時保存靜音狀態 ***
        localStorage.setItem('audioPlayerMuted', audio.muted);
        // 保存播放模式
        localStorage.setItem('audioPlayerMode', playMode);
    } catch (e) {
        console.warn('LocalStorage is not available or blocked.', e);
    }
}

// 從儲存中載入音量、靜音狀態和模式
function loadSavedSettings() {
    try {
        // 載入音量
        const savedVolume = localStorage.getItem('audioPlayerVolume');
        if (savedVolume !== null) {
            // 確保音量在 0.0 到 1.0 之間
            audio.volume = Math.max(0, Math.min(1, parseFloat(savedVolume)));
        }

        // *** 修正：載入靜音狀態 ***
        const savedMuted = localStorage.getItem('audioPlayerMuted');
        if (savedMuted !== null) {
             // localStorage 儲存的是字串 'true' 或 'false'
            audio.muted = (savedMuted === 'true');
        }

        // 載入模式
        const savedMode = localStorage.getItem('audioPlayerMode');
        if (savedMode !== null) {
            const mode = parseInt(savedMode);
            if (mode >= 0 && mode <= 3) {
                playMode = mode;
                updateModeUI(); 
            }
        }
    } catch (e) {
        console.warn('Failed to load settings from LocalStorage.', e);
    }
}

// 專門用於載入設定時更新模式 UI 
function updateModeUI() {
    let modeText;
    if (playMode === 1) {
        modeText = "[ 模式: 循環 ]";
    } else if (playMode === 2) {
        modeText = "[ 模式: 隨機 ]";
    } else if (playMode === 3) {
        modeText = "[ 模式: 自由 ]";
    } else {
        modeText = "[ 模式: 順序 ]";
    }
    modeButton.textContent = modeText;
}

// 監聽音量變更和靜音狀態變更事件，以便儲存
// *** 修正：音量和靜音狀態變更都呼叫 saveSettings ***
audio.addEventListener('volumechange', saveSettings);
audio.addEventListener('ratechange', saveSettings); // 某些瀏覽器可能需要
audio.addEventListener('loadedmetadata', saveSettings); // 首次載入 metadata 後儲存一次


// --- 初始化 (已將 initializeTheme 移至此處) ---

// 1. 載入儲存的設定（必須在初始化時第一步執行）
loadSavedSettings();

// *** 2. 初始化主題設定 (自動或手動) ***
initializeTheme();

// 3. 載入並高亮第一首歌
updatePlaylistHighlight(); 

// 4. 確保模式 UI 在載入後是正確的（如果 loadSavedSettings 更改了 playMode）
//    updateModeUI(); // 已包含在 loadSavedSettings 內部
</script>
