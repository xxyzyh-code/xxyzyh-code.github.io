# .github/workflows/deploy_to_ipfs.yml
name: Jekyll Build & Deploy to IPFS

on:
  push:
    branches:
      - main  # ç•¶æ¨é€åˆ° main åˆ†æ”¯æ™‚è§¸ç™¼æ­¤å·¥ä½œæµç¨‹

jobs:
  deploy_ipfs:
    runs-on: ubuntu-latest

    steps:
      # 1. æª¢æŸ¥ç¨‹å¼ç¢¼
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }} # ç¢ºä¿æœ‰æ¬Šé™æ¨é€ CID æ–‡ä»¶

      # --- ğŸš€ è¤‡è£½æ‚¨ç¾æœ‰çš„ Jekyll æ§‹å»ºæµç¨‹ ---

      # 2. è¨­å®š Ruby ç’°å¢ƒ
      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2' # ä¿æŒèˆ‡æ‚¨ Netlify æµç¨‹ä¸€è‡´çš„ Ruby ç‰ˆæœ¬
          bundler-cache: true 

      # 3. å®‰è£ Jekyll ä¾è³´
      - name: Install dependencies
        run: |
          gem install bundler
          bundle install

      # 4. åŸ·è¡Œ Jekyll å»ºæ§‹ (è¼¸å‡ºåˆ° _site ç›®éŒ„)
      - name: Build Jekyll site
        run: |
          echo "ğŸ’¡ Starting Jekyll build..."
          JEKYLL_ENV=production bundle exec jekyll build --config _config.yml
          echo "âœ… Jekyll build complete. Files are in _site/."
      
      # --- Jekyll æ§‹å»ºæµç¨‹çµæŸ ---


      # 5. è¨­å®š Node.js å’Œ IPFS ä¾è³´
      - name: Setup Node.js (for IPFS client)
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install IPFS dependencies
        run: npm install ipfs-http-client node-fetch

      # 6. ä¸Šå‚³åˆ° IPFS å’Œ Pinning
      - name: Upload to IPFS and Pin
        id: ipfs_deploy
        env:
          INFURA_PROJECT_ID: ${{ secrets.INFURA_PROJECT_ID }}
          INFURA_PROJECT_SECRET: ${{ secrets.INFURA_PROJECT_SECRET }}
          CID_FILE_NAME: cid_output.txt 
          BUILD_DIR: _site 
        run: |
          node <<'EOF'
          import { create } from 'ipfs-http-client';
          import fs from 'fs';
          import path from 'path';
          import fetch from 'node-fetch';

          const projectId = process.env.INFURA_PROJECT_ID;
          const projectSecret = process.env.INFURA_PROJECT_SECRET;
          const cidFileName = process.env.CID_FILE_NAME;
          const buildDir = process.env.BUILD_DIR; 
          
          if (!projectId || !projectSecret) {
            console.error("âŒ INFURA_PROJECT_ID or SECRET is missing. Cannot deploy.");
            process.exit(1);
          }
          
          const auth =
            'Basic ' + Buffer.from(projectId + ':' + projectSecret).toString('base64');

          const client = create({
            host: 'ipfs.infura.io',
            port: 5001,
            protocol: 'https',
            headers: { authorization: auth },
          });
          
          async function addDirectory(dir) {
            const files = [];
            function walk(currentPath, baseDir) {
              const entries = fs.readdirSync(currentPath);
              for (const entry of entries) {
                const fullPath = path.join(currentPath, entry);
                
                if (fs.statSync(fullPath).isDirectory()) {
                  walk(fullPath, baseDir);
                } else {
                  const content = fs.readFileSync(fullPath);
                  const relativePath = path.relative(baseDir, fullPath);
                  files.push({
                    path: relativePath,
                    content
                  });
                }
              }
            }
            
            console.log(`ğŸ” Preparing to upload directory: ${dir}`);
            walk(dir, dir); 

            if (files.length === 0) {
              console.error("âŒ No files found in build directory. Check Jekyll build step.");
              process.exit(1);
            }
            
            const root = await client.addAll(files, { wrapWithDirectory: true });
            let last;
            for await (const f of root) last = f;
            return last.cid.toString();
          }

          (async () => {
            try {
              const rootCid = await addDirectory(path.join(process.cwd(), buildDir)); 
              console.log(`âœ… Upload complete!`);
              console.log(`ğŸŒ Your website CID: ${rootCid}`);
              
              fs.writeFileSync(cidFileName, rootCid);
              
              console.log(`ğŸ“Œ Pinning to Infura...`);

              const response = await fetch('https://ipfs.infura.io:5001/api/v0/pin/add?arg=' + rootCid, {
                method: 'POST',
                headers: { authorization: auth }
              });
              
              if (!response.ok) {
                console.error(`âŒ Pinning failed: ${response.status} ${response.statusText}`);
                try {
                    const errorResult = await response.text();
                    console.error('Pinning Error Response:', errorResult);
                } catch (e) {
                    console.error('Could not read error response text.');
                }
              } else {
                  try {
                      const result = await response.json();
                      console.log('ğŸ“Œ Pin result:', result);
                  } catch (e) {
                      console.warn('âš ï¸ Pinning response was not JSON, but status was OK.');
                  }
              }
              console.log(`ğŸŒ Your website is now accessible at: https://ipfs.io/ipfs/${rootCid}`);

            } catch (error) {
                console.error("âŒ Critical IPFS Deployment Error:", error);
                process.exit(1);
            }
          })();
          EOF
          
          NEW_CID=$(cat $CID_FILE_NAME)
          echo "NEW_CID=$NEW_CID" >> $GITHUB_OUTPUT


      # 7. æ›´æ–° CID æ­·å²å’Œæœ€æ–°é€£çµæ–‡ä»¶
      - name: Update CID History and Latest Link ğŸ“
        if: success() 
        env:
          NEW_CID: ${{ steps.ipfs_deploy.outputs.NEW_CID }} 
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          LATEST_CID_FILE="CID_LATEST.md"
          HISTORY_CID_FILE="CID_HISTORY.md"
          IPFS_GATEWAY="https://ipfs.io/ipfs"
          CID_LINK="$IPFS_GATEWAY/$NEW_CID"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # æª¢æŸ¥ CID æ˜¯å¦æœ‰è®Šæ›´
          OLD_CID=""
          if [ -f $LATEST_CID_FILE ]; then
              OLD_CID=$(grep 'CID:' $LATEST_CID_FILE | head -1 | sed -e 's/.*`\([a-zA-Z0-9]*\)`/\1/')
          fi

          if [ "$NEW_CID" = "$OLD_CID" ]; then
              echo "CID ($NEW_CID) æœªè®Šæ›´ï¼Œç„¡éœ€æ¨é€æ–‡ä»¶ã€‚"
              exit 0 
          fi
          
          echo "ğŸ”‘ CID è®Šæ›´åµæ¸¬åˆ°ã€‚æ­£åœ¨æ›´æ–°æ–‡ä»¶..."

          # æ›´æ–° LATEST CID æ–‡ä»¶ (è¦†è“‹)
          cat > $LATEST_CID_FILE <<EOL
# ğŸŒ æœ€æ–° IPFS éƒ¨ç½²é€£çµ

---
### ğŸš€ æœ€æ–°éƒ¨ç½²
ğŸ“… **æ™‚é–“ (UTC):** \`${TIMESTAMP}\`
ğŸ†” **CID:** \`${NEW_CID}\`
ğŸ”— **è¨ªå•é€£çµ:** [é»æ“Šæ­¤è™•è¨ªå•]($CID_LINK)
EOL

          # æ›´æ–° CID æ­·å²æ–‡ä»¶ (Append ä¸¦æ’åºåˆ°æœ€å‰)
          NEW_ENTRY="---
### ğŸ“¦ éƒ¨ç½²æ–¼ $TIMESTAMP
* **CID:** \`${NEW_CID}\`
* **é€£çµ:** [è¨ªå•]($CID_LINK)"

          if [ ! -f $HISTORY_CID_FILE ]; then
              echo "# ğŸ“œ IPFS éƒ¨ç½²æ­·å²è¨˜éŒ„" > $HISTORY_CID_FILE
              echo "$NEW_ENTRY" >> $HISTORY_CID_FILE
          else
              TEMP_FILE=$(mktemp)
              # è®€å–é™¤äº†æ¨™é¡Œè¡Œä¹‹å¤–çš„å…§å®¹
              tail -n +2 $HISTORY_CID_FILE > $TEMP_FILE 
              
              # é‡æ–°å¯«å…¥æ¨™é¡Œå’Œæ–°æ¢ç›®
              echo "# ğŸ“œ IPFS éƒ¨ç½²æ­·å²è¨˜éŒ„" > $HISTORY_CID_FILE
              echo "$NEW_ENTRY" >> $HISTORY_CID_FILE
              
              # é™„åŠ èˆŠçš„æ­·å²è¨˜éŒ„
              cat $TEMP_FILE >> $HISTORY_CID_FILE
              rm $TEMP_FILE
          fi
          
          # æäº¤å’Œæ¨é€æ›´æ”¹
          echo "æ­£åœ¨æäº¤å’Œæ¨é€ CID æ–‡ä»¶..."
          git add $LATEST_CID_FILE $HISTORY_CID_FILE
          git commit -m "ğŸ¤– [CI] Auto-update IPFS CID to $NEW_CID"
          git push
